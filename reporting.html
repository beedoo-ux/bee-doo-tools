<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>bee-doo ¬∑ Reporting Dashboard</title>
<link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700;800&display=swap" rel="stylesheet" />
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&display=swap" rel="stylesheet" />
<script src="config.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.3.1/umd/react.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.3.1/umd/react-dom.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prop-types/15.8.1/prop-types.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/recharts/2.12.7/Recharts.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.26.2/babel.min.js"></script>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #06080F; color: #e1e7ef; font-family: 'DM Sans', system-ui, sans-serif; -webkit-font-smoothing: antialiased; }
button, select, input { color: inherit; font-family: inherit; }
::-webkit-scrollbar { width: 6px; height: 6px; }
::-webkit-scrollbar-track { background: #0D1117; }
::-webkit-scrollbar-thumb { background: #1B2332; border-radius: 3px; }
.back-btn { position: fixed; top: 10px; left: 10px; z-index: 9999; background: #1a1d27; border: 1px solid #2a2d3a; color: #94a3b8; padding: 6px 14px; border-radius: 8px; font-size: 12px; cursor: pointer; text-decoration: none; transition: all .15s; }
.back-btn:hover { border-color: #F5C500; color: #F5C500; }

/* Responsive */
@media (max-width: 768px) {
  .grid-cards { grid-template-columns: repeat(2, 1fr) !important; }
  .grid-1 { grid-template-columns: 1fr !important; }
  .flex-wrap-tablet { flex-wrap: wrap !important; }
  .pad-reduce { padding: 16px !important; }
}
@media (max-width: 480px) {
  .grid-cards { grid-template-columns: 1fr !important; }
  .grid-1 { grid-template-columns: 1fr !important; }
  .pad-reduce { padding: 10px !important; }
  input, select, textarea { font-size: 16px !important; }
  button { min-height: 44px !important; }
}
</style>
</head>
<body>
<a href="index.html" class="back-btn">‚Üê Launcher</a>
<div id="root"></div>
<script type="text/babel">
const { useState, useEffect, useMemo, useCallback } = React;
const { BarChart, Bar, XAxis, YAxis, Tooltip, ResponsiveContainer, PieChart, Pie, Cell, Legend, CartesianGrid, AreaChart, Area, ComposedChart, Line } = Recharts;

// ‚ïê‚ïê‚ïê THEME ‚ïê‚ïê‚ïê
const C = {
  bg: "#06080F", card: "#0D1117", card2: "#111821", border: "#1B2332",
  text: "#E6EDF3", sec: "#8B949E", dim: "#484F58", muted: "#6B7685",
  gold: "#F5C500", amber: "#F0A030", green: "#3FB950", red: "#F85149",
  blue: "#58A6FF", purple: "#BC8CFF", pink: "#F778BA", cyan: "#56D4DD",
  orange: "#F0883E", teal: "#2EA043",
};
const CL = [C.gold, C.blue, C.green, C.red, C.purple, C.pink, C.cyan, C.orange, C.teal, "#A371F7", "#D2A8FF"];

// ‚ïê‚ïê‚ïê SUPABASE CONFIG ‚ïê‚ïê‚ïê
const SB_URL = window.BEEDOO_CONFIG?.SB_URL || 'https://hqzpemfaljxcysyqssng.supabase.co';
const SB_KEY = window.BEEDOO_CONFIG?.SB_SERVICE_KEY || 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImhxenBlbWZhbGp4Y3lzeXFzc25nIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc3MTMzNTM5NywiZXhwIjoyMDg2OTExMzk3fQ.MJ3cyAAquE8DK2ngzfIIn4bTpQ8_H9DaeJ3YTlBdFz4';

async function sbFetch(table, params = '') {
  const url = `${SB_URL}/rest/v1/${table}${params ? '?' + params : ''}`;
  const res = await fetch(url, {
    headers: { 'apikey': SB_KEY, 'Authorization': `Bearer ${SB_KEY}` }
  });
  if (!res.ok) throw new Error(`Supabase ${table}: ${res.status}`);
  return res.json();
}

async function sbCount(table, params = '') {
  const url = `${SB_URL}/rest/v1/${table}?select=id&limit=1${params ? '&' + params : ''}`;
  const res = await fetch(url, {
    headers: { 'apikey': SB_KEY, 'Authorization': `Bearer ${SB_KEY}`, 'Prefer': 'count=exact' }
  });
  const range = res.headers.get('content-range');
  return range ? parseInt(range.split('/')[1]) || 0 : 0;
}

// Paginated fetch for large tables
async function sbFetchAll(table, params = '', pageSize = 500) {
  let all = [], offset = 0, hasMore = true;
  while (hasMore) {
    const sep = params ? '&' : '';
    const url = `${SB_URL}/rest/v1/${table}?${params}${sep}limit=${pageSize}&offset=${offset}`;
    const res = await fetch(url, {
      headers: { 'apikey': SB_KEY, 'Authorization': `Bearer ${SB_KEY}`, 'Prefer': 'count=exact' }
    });
    if (!res.ok) throw new Error(`Supabase ${table}: ${res.status}`);
    const data = await res.json();
    all = all.concat(data);
    hasMore = data.length === pageSize;
    offset += pageSize;
    if (offset > 50000) break; // Safety limit
  }
  return all;
}

// ‚ïê‚ïê‚ïê HELPERS ‚ïê‚ïê‚ïê
const fmt = n => typeof n === "number" ? n.toLocaleString("de-DE") : n;
const eur = n => {
  if (n == null) return "‚Äì";
  if (n >= 1000000) return `${(n/1000000).toFixed(2).replace('.',',')}M ‚Ç¨`;
  if (n >= 1000) return `${(n/1000).toFixed(n >= 100000 ? 0 : 1).replace('.',',')}k ‚Ç¨`;
  return `${fmt(Math.round(n))} ‚Ç¨`;
};
const pct = (a, b) => b > 0 ? ((a / b) * 100).toFixed(1) : "0.0";
const dayName = d => ['So','Mo','Di','Mi','Do','Fr','Sa'][new Date(d).getDay()];
const fmtDate = d => {
  const dt = new Date(d);
  return `${String(dt.getDate()).padStart(2,'0')}.${String(dt.getMonth()+1).padStart(2,'0')}.`;
};
const monthNames = ['Jan','Feb','M√§r','Apr','Mai','Jun','Jul','Aug','Sep','Okt','Nov','Dez'];

// ‚ïê‚ïê‚ïê MONTH HELPERS ‚ïê‚ïê‚ïê
function getMonthRange(year, month) {
  const start = `${year}-${String(month).padStart(2,'0')}-01`;
  const endDate = new Date(year, month, 0);
  const end = `${year}-${String(month).padStart(2,'0')}-${String(endDate.getDate()).padStart(2,'0')}`;
  const nextMonth = month === 12 ? `${year+1}-01-01` : `${year}-${String(month+1).padStart(2,'0')}-01`;
  return { start, end, nextMonth, daysInMonth: endDate.getDate() };
}

function getAvailableMonths() {
  const months = [{ year: 0, month: 0, label: 'Alle (ab Okt 2025)' }];
  const now = new Date();
  const minDate = new Date(2025, 9, 1); // Oktober 2025
  for (let i = 0; i < 24; i++) {
    const d = new Date(now.getFullYear(), now.getMonth() - i, 1);
    if (d < minDate) break;
    months.push({ year: d.getFullYear(), month: d.getMonth() + 1, label: `${monthNames[d.getMonth()]} ${d.getFullYear()}` });
  }
  return months;
}

// ‚ïê‚ïê‚ïê DATA PROCESSING ‚ïê‚ïê‚ïê
function processAuftraege(auftraege, mitarbeiterMap) {
  const total = auftraege.length;
  const aktiv = auftraege.filter(a => !a.storniert);
  const storno = auftraege.filter(a => a.storniert);

  const nettoAktiv = aktiv.reduce((s, a) => s + (a.an_wert_netto || 0) / 100, 0);
  const nettoGesamt = auftraege.reduce((s, a) => s + (a.an_wert_netto || 0) / 100, 0);
  const nettoStorno = storno.reduce((s, a) => s + (a.an_wert_netto || 0) / 100, 0);
  const avgNetto = aktiv.length > 0 ? nettoAktiv / aktiv.length : 0;

  const speicher = aktiv.filter(a => a.hat_speicher).length;
  const kwpValues = aktiv.map(a => (a.anlagen_kwp || 0) / 100).filter(v => v > 0.5 && v < 100);
  const avgKwp = kwpValues.length > 0 ? kwpValues.reduce((s, v) => s + v, 0) / kwpValues.length : 0;
  const moduleValues = aktiv.map(a => a.angebot_module || 0).filter(v => v > 0);
  const avgModule = moduleValues.length > 0 ? moduleValues.reduce((s, v) => s + v, 0) / moduleValues.length : 0;

  // Daily breakdown
  const dailyMap = {};
  auftraege.forEach(a => {
    const d = a.auftrags_datum;
    if (!d) return;
    if (!dailyMap[d]) dailyMap[d] = { d: fmtDate(d), raw: d, total: 0, aktiv: 0, storno: 0, netto: 0 };
    dailyMap[d].total++;
    if (a.storniert) dailyMap[d].storno++;
    else { dailyMap[d].aktiv++; dailyMap[d].netto += (a.an_wert_netto || 0) / 100; }
  });
  const daily = Object.values(dailyMap).sort((a, b) => a.raw.localeCompare(b.raw));

  // Weekday breakdown
  const wdMap = { Mo: { v: 0, days: new Set() }, Di: { v: 0, days: new Set() }, Mi: { v: 0, days: new Set() }, Do: { v: 0, days: new Set() }, Fr: { v: 0, days: new Set() }, Sa: { v: 0, days: new Set() }, So: { v: 0, days: new Set() } };
  aktiv.forEach(a => {
    if (!a.auftrags_datum) return;
    const wd = dayName(a.auftrags_datum);
    if (wdMap[wd]) { wdMap[wd].v++; wdMap[wd].days.add(a.auftrags_datum); }
  });
  const weekday = ['Mo','Di','Mi','Do','Fr','Sa','So'].map(d => ({
    d, v: wdMap[d].v, days: wdMap[d].days.size, avg: wdMap[d].days.size > 0 ? (wdMap[d].v / wdMap[d].days.size).toFixed(1) : '0'
  })).filter(w => w.v > 0);

  // Berater breakdown
  const beraterMap = {};
  auftraege.forEach(a => {
    const vid = a.vertriebler_id;
    const name = vid ? (mitarbeiterMap[vid] || `ID ${vid.slice(0,6)}`) : 'Nicht zugewiesen';
    if (!beraterMap[name]) beraterMap[name] = { n: name, s: 0, st: 0, net: 0, speicher: 0 };
    if (a.storniert) beraterMap[name].st++;
    else {
      beraterMap[name].s++;
      beraterMap[name].net += (a.an_wert_netto || 0) / 100;
      if (a.hat_speicher) beraterMap[name].speicher++;
    }
  });
  const berater = Object.values(beraterMap).sort((a, b) => {
    if (a.n === 'Nicht zugewiesen') return 1;
    if (b.n === 'Nicht zugewiesen') return -1;
    return b.s - a.s || b.net - a.net;
  });

  // Quellen breakdown
  const quellenMap = {};
  auftraege.forEach(a => {
    const q = a.lead_quelle || 'Unbekannt';
    if (!quellenMap[q]) quellenMap[q] = { n: q, s: 0, b: 0, st: 0, net: 0 };
    quellenMap[q].b++;
    if (a.storniert) quellenMap[q].st++;
    else { quellenMap[q].s++; quellenMap[q].net += (a.an_wert_netto || 0) / 100; }
  });
  const quellen = Object.values(quellenMap).sort((a, b) => b.s - a.s);

  // kWp distribution
  const kwpDist = [
    { name: '<8 kWp', v: kwpValues.filter(v => v < 8).length },
    { name: '8‚Äì12 kWp', v: kwpValues.filter(v => v >= 8 && v < 12).length },
    { name: '‚â•12 kWp', v: kwpValues.filter(v => v >= 12).length },
  ];

  return {
    total, aktiv: aktiv.length, storno: storno.length,
    nettoGesamt, nettoAktiv, nettoStorno, avgNetto,
    speicher, avgKwp: +avgKwp.toFixed(1), avgModule: +avgModule.toFixed(0),
    daily, weekday, berater, quellen, kwpDist,
  };
}

function processLeads(leads) {
  const total = leads.length;

  // ‚îÄ‚îÄ Status categorization ‚îÄ‚îÄ
  const isTerm = s => /terminiert|termin gelegt|termin vor ort|angebot/i.test(s);
  const isAuftrag = s => /auftrag|vertrag|sale/i.test(s);
  const isStorno = s => /storn/i.test(s);
  const isNE = s => /nicht erreicht/i.test(s);
  const isKeinInt = s => /kein interesse/i.test(s);
  const isRekl = s => /reklamation/i.test(s);
  const isNeu = s => /neuer lead|neu$/i.test(s);
  const isWVL = s => /wvl|wiedervorlage/i.test(s);
  const isNoPLZ = s => /nicht im plz/i.test(s);

  // ‚îÄ‚îÄ Funnel KPIs ‚îÄ‚îÄ
  let terminiert=0, auftrag=0, storno=0, ne=0, keinInt=0, rekl=0, neu=0, wvl=0, noPLZ=0, optIn=0, hasEFS=0;
  leads.forEach(l => {
    const sn = (l.status_name||'').trim();
    if(isTerm(sn)) terminiert++;
    if(isAuftrag(sn)) auftrag++;
    if(isStorno(sn)) storno++;
    if(isNE(sn)) ne++;
    if(isKeinInt(sn)) keinInt++;
    if(isRekl(sn)) rekl++;
    if(isNeu(sn)) neu++;
    if(isWVL(sn)) wvl++;
    if(isNoPLZ(sn)) noPLZ++;
    if(l.opt_in_bestaetigt) optIn++;
    if(l.efs_id) hasEFS++;
  });

  // ‚îÄ‚îÄ Status breakdown ‚îÄ‚îÄ
  const statusMap = {};
  leads.forEach(l => {
    const s = (l.status_name || 'Unbekannt').trim();
    if (!statusMap[s]) statusMap[s] = 0;
    statusMap[s]++;
  });
  const statusColors = { 'Terminiert': C.green, 'Termin gelegt': '#3FB950', 'REKLAMATION': C.red, 'Nicht erreicht': C.orange, 'Nicht im PLZ-Gebiet': C.purple, 'WVL': C.blue, '5x NICHT ERREICHT': '#D29922', 'Neuer Lead': C.cyan, 'Kein Interesse': C.dim, 'Auftrag': C.gold, 'Storniert': C.red };
  const status = Object.entries(statusMap)
    .map(([name, v]) => ({ name, v, fill: statusColors[name] || C.muted }))
    .sort((a, b) => b.v - a.v);

  // ‚îÄ‚îÄ Timeline (daily) ‚îÄ‚îÄ
  const dailyMap = {};
  leads.forEach(l => {
    const d = (l.erster_status_datum || l.leveto_erstellt_am || '').substring(0,10);
    if(!d || d < '2025-01-01') return;
    if(!dailyMap[d]) dailyMap[d] = { d, total: 0, term: 0, ne: 0 };
    dailyMap[d].total++;
    const sn = (l.status_name||'').trim();
    if(isTerm(sn)||isAuftrag(sn)) dailyMap[d].term++;
    if(isNE(sn)) dailyMap[d].ne++;
  });
  const timeline = Object.values(dailyMap).sort((a,b)=>a.d.localeCompare(b.d));
  // Aggregate to weekly for cleaner charts
  const weeklyMap = {};
  timeline.forEach(d => {
    const dt = new Date(d.d);
    const wk = new Date(dt.setDate(dt.getDate()-dt.getDay()+1));
    const key = wk.toISOString().substring(0,10);
    if(!weeklyMap[key]) weeklyMap[key] = { d: `KW ${Math.ceil((new Date(key).getTime()-new Date(key.substring(0,4)+'-01-01').getTime())/604800000)}`, raw: key, total: 0, term: 0 };
    weeklyMap[key].total += d.total;
    weeklyMap[key].term += d.term;
  });
  const weekly = Object.values(weeklyMap).sort((a,b)=>a.raw.localeCompare(b.raw)).slice(-16);

  // ‚îÄ‚îÄ Geographic (Stadt/PLZ) ‚îÄ‚îÄ
  const ortMap = {};
  leads.forEach(l => {
    const o = (l.ort||'').trim();
    if(!o) return;
    if(!ortMap[o]) ortMap[o] = { n: o, total: 0, term: 0, plz: l.plz||'' };
    ortMap[o].total++;
    const sn = (l.status_name||'').trim();
    if(isTerm(sn)||isAuftrag(sn)) ortMap[o].term++;
  });
  const topOrte = Object.values(ortMap).sort((a,b)=>b.total-a.total).slice(0,20);
  const plzMap = {};
  leads.forEach(l => {
    const p = (l.plz||'').substring(0,2);
    if(!p) return;
    if(!plzMap[p]) plzMap[p] = { n: p+'xxx', total: 0, term: 0 };
    plzMap[p].total++;
    const sn = (l.status_name||'').trim();
    if(isTerm(sn)||isAuftrag(sn)) plzMap[p].term++;
  });
  const plzRegionen = Object.values(plzMap).sort((a,b)=>b.total-a.total).slice(0,15);

  // ‚îÄ‚îÄ Quellen with conversion ‚îÄ‚îÄ
  const quellenMap = {};
  leads.forEach(l => {
    const q = l.quelle || 'Unbekannt';
    if (!quellenMap[q]) quellenMap[q] = { n: q, total: 0, term: 0, rekl: 0, ne: 0, auftrag: 0, storno: 0 };
    quellenMap[q].total++;
    const sn = (l.status_name || '').trim();
    if (isTerm(sn)) quellenMap[q].term++;
    if (isRekl(sn)) quellenMap[q].rekl++;
    if (isNE(sn)) quellenMap[q].ne++;
    if (isAuftrag(sn)) quellenMap[q].auftrag++;
    if (isStorno(sn)) quellenMap[q].storno++;
  });
  const quellen = Object.values(quellenMap).sort((a, b) => b.total - a.total);

  // ‚îÄ‚îÄ Berater performance ‚îÄ‚îÄ
  const beraterLeadMap = {};
  leads.forEach(l => {
    const b = l.berater_name || 'Nicht zugewiesen';
    if (!beraterLeadMap[b]) beraterLeadMap[b] = { n: b, total: 0, term: 0, auftrag: 0, ne: 0, storno: 0 };
    beraterLeadMap[b].total++;
    const sn = (l.status_name || '').trim();
    if (isTerm(sn) || isAuftrag(sn)) beraterLeadMap[b].term++;
    if (isAuftrag(sn)) beraterLeadMap[b].auftrag++;
    if (isNE(sn)) beraterLeadMap[b].ne++;
    if (isStorno(sn)) beraterLeadMap[b].storno++;
  });
  const beraterLeads = Object.values(beraterLeadMap).sort((a, b) => b.term - a.term);

  // ‚îÄ‚îÄ Processing speed (Erstellt ‚Üí Status) ‚îÄ‚îÄ
  let processingTimes = [];
  leads.forEach(l => {
    if(l.leveto_erstellt_am && l.status_datum && l.status_datum !== l.leveto_erstellt_am) {
      const diff = (new Date(l.status_datum) - new Date(l.leveto_erstellt_am)) / 3600000;
      if(diff > 0 && diff < 720) processingTimes.push(diff);
    }
  });
  processingTimes.sort((a,b)=>a-b);
  const medianProcessing = processingTimes.length > 0 ? processingTimes[Math.floor(processingTimes.length/2)] : 0;
  const avgProcessing = processingTimes.length > 0 ? processingTimes.reduce((s,v)=>s+v,0)/processingTimes.length : 0;

  // ‚îÄ‚îÄ Anrede/Geschlecht ‚îÄ‚îÄ
  const anredeMap = {};
  leads.forEach(l => {
    const a = l.anrede || 'Unbekannt';
    if(!anredeMap[a]) anredeMap[a] = 0;
    anredeMap[a]++;
  });

  // ‚îÄ‚îÄ Status indicator breakdown ‚îÄ‚îÄ
  const indicatorMap = {};
  leads.forEach(l => {
    const i = l.status_indicator || 'Unbekannt';
    if(!indicatorMap[i]) indicatorMap[i] = 0;
    indicatorMap[i]++;
  });

  return {
    total, status, quellen, beraterLeads, weekly, topOrte, plzRegionen, anredeMap, indicatorMap,
    funnel: { terminiert, auftrag, storno, ne, keinInt, rekl, neu, wvl, noPLZ, optIn, hasEFS },
    processing: { median: medianProcessing, avg: avgProcessing, count: processingTimes.length },
  };
}

function processTermine(termine) {
  const total = termine.length;
  const now = new Date();
  const today = now.toISOString().slice(0, 10);

  // Split past vs future
  let nStattgefunden = 0, nAusgefallen = 0, nZukunft = 0, nHeute = 0;
  // Past: Closed + Open = stattgefunden (Open in past = nicht ausgewertet aber stattgefunden)
  // Cancelled = ausgefallen
  termine.forEach(t => {
    const d = (t.start_date || '').slice(0, 10);
    if (d === today) nHeute++;
    if (d > today) { nZukunft++; return; }
    // Past or today
    if (t.status === 'Cancelled') nAusgefallen++;
    else nStattgefunden++; // Closed + Open in past = stattgefunden
  });
  const nVergangenheit = nStattgefunden + nAusgefallen;
  const convRate = nVergangenheit > 0 ? (nStattgefunden / nVergangenheit * 100) : 0;

  // Termine gelegt heute (by creation_date)
  let nGelegtHeute = 0;
  termine.forEach(t => {
    const cd = (t.creation_date || '').slice(0, 10);
    if (cd === today) nGelegtHeute++;
  });

  // Daily chart ‚Äì by start_date, 3 bars: gesamt, stattgefunden, ausgefallen
  const dailyMap = {};
  termine.forEach(t => {
    const d = (t.start_date || '').slice(0, 10);
    if (!d) return;
    if (!dailyMap[d]) dailyMap[d] = { d: fmtDate(d), raw: d, gesamt: 0, stattgef: 0, ausgef: 0 };
    dailyMap[d].gesamt++;
    if (d <= today) {
      if (t.status === 'Cancelled') dailyMap[d].ausgef++;
      else dailyMap[d].stattgef++;
    }
  });
  const daily = Object.values(dailyMap).sort((a, b) => a.raw.localeCompare(b.raw));

  // By Quelle
  const quellenMap = {};
  termine.forEach(t => {
    const q = t.quelle || 'Unbekannt';
    if (!quellenMap[q]) quellenMap[q] = { name: q, total: 0, stattgefunden: 0, ausgefallen: 0 };
    quellenMap[q].total++;
    const d = (t.start_date || '').slice(0, 10);
    if (d <= today) {
      if (t.status === 'Cancelled') quellenMap[q].ausgefallen++;
      else quellenMap[q].stattgefunden++;
    }
  });
  const quellen = Object.values(quellenMap).sort((a, b) => b.total - a.total);

  // By Berater
  const beraterTermMap = {};
  termine.forEach(t => {
    const name = t.berater || 'Nicht zugewiesen';
    if (!beraterTermMap[name]) beraterTermMap[name] = { n: name, total: 0, stattgefunden: 0, ausgefallen: 0 };
    beraterTermMap[name].total++;
    const d = (t.start_date || '').slice(0, 10);
    if (d <= today) {
      if (t.status === 'Cancelled') beraterTermMap[name].ausgefallen++;
      else beraterTermMap[name].stattgefunden++;
    }
  });
  const berater = Object.values(beraterTermMap)
    .sort((a, b) => a.n === 'Nicht zugewiesen' ? 1 : b.n === 'Nicht zugewiesen' ? -1 : b.total - a.total);

  return { total, nStattgefunden, nAusgefallen, nZukunft, nHeute, nGelegtHeute, convRate, daily, quellen, berater };
}

function processEFS(projekte) {
  const total = projekte.length;
  const byStatus = {};
  projekte.forEach(p => {
    const s = p.simplified_status || 'UNKNOWN';
    byStatus[s] = (byStatus[s] || 0) + 1;
  });

  const statusLabels = {
    CREATED: 'Erstellt', PRE_APPROVED: 'Vorgepr√ºft', PROJECT_APPROVED: 'Genehmigt',
    REVOCATION_PERIOD: 'Widerrufsfrist', INSTALLATION_CONFIRMED: 'Montage best√§tigt',
    INSTALLED: 'Installiert', GRID_CONNECTED: 'Netzanschluss', COMPLETED: 'Abgeschlossen',
    REVOKED: 'Widerrufen', CUSTOMER_REJECTED: 'Kunde abgelehnt', REGISTRATION_SENT: 'Anmeldung',
    OFFER_SENT: 'Angebot', OFFER_SIGNED: 'Unterschrieben',
  };
  const statusColors2 = {
    CREATED: C.cyan, PRE_APPROVED: C.blue, PROJECT_APPROVED: C.green,
    REVOCATION_PERIOD: C.amber, INSTALLATION_CONFIRMED: C.gold,
    INSTALLED: C.teal, GRID_CONNECTED: '#3FB950', COMPLETED: '#2EA043',
    REVOKED: C.red, CUSTOMER_REJECTED: C.pink, REGISTRATION_SENT: C.purple,
  };

  const pipeline = Object.entries(byStatus)
    .map(([key, v]) => ({ name: statusLabels[key] || key, v, key, fill: statusColors2[key] || C.muted }))
    .sort((a, b) => b.v - a.v);

  // Revenue
  const activeProjects = projekte.filter(p => !['REVOKED','CUSTOMER_REJECTED'].includes(p.simplified_status));
  const totalRevenue = activeProjects.reduce((s, p) => s + (p.gesamtpreis_eur || 0), 0);
  const avgPrice = activeProjects.length > 0 ? totalRevenue / activeProjects.length : 0;
  const totalKwp = activeProjects.reduce((s, p) => s + (p.pv_kwp || 0), 0);
  const avgKwp = activeProjects.length > 0 ? totalKwp / activeProjects.length : 0;
  const withBat = activeProjects.filter(p => p.bat_kwh && p.bat_kwh > 0).length;

  // Zust√§ndiger breakdown
  const zustMap = {};
  projekte.forEach(p => {
    const z = p.zustaendiger || 'Nicht zugewiesen';
    if (!zustMap[z]) zustMap[z] = { n: z, total: 0, active: 0, revoked: 0, completed: 0, revenue: 0 };
    zustMap[z].total++;
    if (['REVOKED','CUSTOMER_REJECTED'].includes(p.simplified_status)) zustMap[z].revoked++;
    else if (['COMPLETED','GRID_CONNECTED','INSTALLED'].includes(p.simplified_status)) { zustMap[z].completed++; zustMap[z].revenue += (p.gesamtpreis_eur || 0); }
    else { zustMap[z].active++; zustMap[z].revenue += (p.gesamtpreis_eur || 0); }
  });
  const zustaendige = Object.values(zustMap).sort((a, b) => b.total - a.total);

  return { total, pipeline, totalRevenue, avgPrice, totalKwp, avgKwp, withBat, activeCount: activeProjects.length, zustaendige };
}

// ‚ïê‚ïê‚ïê UI COMPONENTS ‚ïê‚ïê‚ïê
const KPI = ({ label, value, sub, color = C.gold, trend }) => (
  <div style={{
    background: `linear-gradient(135deg, ${color}08, ${color}04)`,
    border: `1px solid ${color}20`, borderRadius: 14, padding: '16px 20px',
    flex: '1 1 160px', minWidth: 160,
  }}>
    <div style={{ fontSize: 11, color: C.sec, fontWeight: 600, textTransform: 'uppercase', letterSpacing: 0.5 }}>{label}</div>
    <div style={{ fontSize: 28, fontWeight: 800, color: C.text, fontFamily: "'JetBrains Mono', monospace", marginTop: 4 }}>
      {value}
      {trend && <span style={{ fontSize: 12, color: trend > 0 ? C.green : C.red, marginLeft: 8 }}>{trend > 0 ? '‚ñ≤' : '‚ñº'} {Math.abs(trend)}%</span>}
    </div>
    {sub && <div style={{ fontSize: 11, color: C.muted, marginTop: 4 }}>{sub}</div>}
  </div>
);

const Sec = ({ title, children, sub }) => (
  <div style={{ background: C.card, borderRadius: 16, border: `1px solid ${C.border}`, padding: '20px 24px', overflow: 'hidden' }} className="pad-reduce">
    <div style={{ fontSize: 15, fontWeight: 700, color: C.text, marginBottom: sub ? 2 : 14 }}>{title}</div>
    {sub && <div style={{ fontSize: 11, color: C.sec, marginBottom: 14 }}>{sub}</div>}
    {children}
  </div>
);

const TT = ({ active, payload, label }) => {
  if (!active || !payload?.length) return null;
  return (
    <div style={{ background: '#1a1f2e', border: `1px solid ${C.border}`, borderRadius: 10, padding: '10px 14px', fontSize: 12 }}>
      <div style={{ fontWeight: 700, marginBottom: 4, color: C.text }}>{label}</div>
      {payload.map((p, i) => (
        <div key={i} style={{ color: p.color || C.sec, display: 'flex', justifyContent: 'space-between', gap: 16 }}>
          <span>{p.name}</span><span style={{ fontWeight: 600, fontFamily: "'JetBrains Mono', monospace" }}>{fmt(p.value)}</span>
        </div>
      ))}
    </div>
  );
};

const TabBtn = ({ active, onClick, children, count }) => (
  <button onClick={onClick} style={{
    background: active ? `${C.gold}15` : 'transparent',
    border: `1px solid ${active ? C.gold + '40' : C.border}`,
    color: active ? C.gold : C.sec,
    padding: '8px 18px', borderRadius: 10, fontSize: 13, fontWeight: 600,
    cursor: 'pointer', transition: 'all .15s', display: 'flex', alignItems: 'center', gap: 8,
    whiteSpace: 'nowrap',
  }}>
    {children}
    {count != null && <span style={{ fontSize: 11, opacity: 0.7 }}>({fmt(count)})</span>}
  </button>
);

const RankTable = ({ data, columns }) => (
  <div style={{ overflowX: 'auto' }}>
    <table style={{ width: '100%', borderCollapse: 'collapse', fontSize: 12 }}>
      <thead>
        <tr>{columns.map((col, i) => (
          <th key={i} style={{ textAlign: col.align || 'left', padding: '8px 10px', color: C.sec, fontWeight: 600, borderBottom: `1px solid ${C.border}`, whiteSpace: 'nowrap', fontSize: 11 }}>{col.label}</th>
        ))}</tr>
      </thead>
      <tbody>{data.map((row, ri) => (
        <tr key={ri} style={{ borderBottom: `1px solid ${C.border}15` }}>
          {columns.map((col, ci) => (
            <td key={ci} style={{
              padding: '8px 10px', textAlign: col.align || 'left', whiteSpace: 'nowrap',
              fontFamily: col.mono ? "'JetBrains Mono', monospace" : 'inherit',
              fontWeight: col.bold ? 700 : 400,
              color: col.color ? (typeof col.color === 'function' ? col.color(row) : col.color) : C.text,
              fontSize: 12,
            }}>
              {col.render ? col.render(row, ri) : row[col.key]}
            </td>
          ))}
        </tr>
      ))}</tbody>
    </table>
  </div>
);

const LoadingSpinner = () => (
  <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', padding: 80, gap: 16 }}>
    <div style={{ width: 40, height: 40, border: `3px solid ${C.border}`, borderTop: `3px solid ${C.gold}`, borderRadius: '50%', animation: 'spin 1s linear infinite' }} />
    <div style={{ color: C.sec, fontSize: 14 }}>Lade Live-Daten aus Supabase‚Ä¶</div>
    <style>{`@keyframes spin { to { transform: rotate(360deg); } }`}</style>
  </div>
);

const DataWarning = ({ msg }) => (
  <div style={{ background: `${C.amber}10`, border: `1px solid ${C.amber}30`, borderRadius: 10, padding: '10px 16px', fontSize: 12, color: C.amber, display: 'flex', alignItems: 'center', gap: 8 }}>
    ‚ö†Ô∏è {msg}
  </div>
);

// ‚ïê‚ïê‚ïê TAB: SALES ‚ïê‚ïê‚ïê
const TabSales = ({ data }) => {
  const d = data;
  if (!d) return null;

  return (
    <div style={{ display: 'flex', flexDirection: 'column', gap: 18 }}>
      {/* KPIs */}
      <div style={{ display: 'flex', gap: 12, flexWrap: 'wrap' }} className="grid-cards">
        <KPI label="Auftr√§ge gesamt" value={fmt(d.total)} sub={`${d.aktiv} aktiv ¬∑ ${d.storno} storniert (${pct(d.storno, d.total)}%)`} color={C.gold} />
        <KPI label="Netto aktiv" value={eur(d.nettoAktiv)} sub={`√ò ${eur(d.avgNetto)} ¬∑ Gesamt: ${eur(d.nettoGesamt)}`} color={C.green} />
        <KPI label="Stornoquote" value={`${pct(d.storno, d.total)}%`} sub={`${d.storno} Stornos ¬∑ ${eur(d.nettoStorno)} Verlust`} color={C.red} />
        <KPI label="√ò Anlage" value={`${d.avgKwp} kWp`} sub={`√ò ${d.avgModule} Module ¬∑ ${d.speicher} mit Speicher`} color={C.blue} />
      </div>

      {/* Daily Sales Chart */}
      <Sec title="üìà T√§gliche Auftr√§ge (aktiv)" sub={`${d.daily.length} Tage mit Auftr√§gen`}>
        <ResponsiveContainer width="100%" height={280}>
          <ComposedChart data={d.daily}>
            <CartesianGrid strokeDasharray="3 3" stroke={C.border} />
            <XAxis dataKey="d" tick={{ fill: C.sec, fontSize: 10 }} interval={Math.max(0, Math.floor(d.daily.length / 15))} />
            <YAxis tick={{ fill: C.sec, fontSize: 10 }} />
            <Tooltip content={<TT />} />
            <Bar dataKey="aktiv" fill={C.gold} name="Aktive Auftr√§ge" radius={[4,4,0,0]} />
            <Bar dataKey="storno" fill={`${C.red}60`} name="Storniert" radius={[4,4,0,0]} />
            <Line dataKey="aktiv" type="monotone" stroke={C.amber} strokeWidth={2} dot={false} name="Trend" />
          </ComposedChart>
        </ResponsiveContainer>
      </Sec>

      {/* Two column: Weekday + kWp */}
      <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: 18 }} className="grid-1">
        <Sec title="üìä Wochentags-Verteilung">
          <ResponsiveContainer width="100%" height={200}>
            <BarChart data={d.weekday}>
              <CartesianGrid strokeDasharray="3 3" stroke={C.border} />
              <XAxis dataKey="d" tick={{ fill: C.sec, fontSize: 11 }} />
              <YAxis tick={{ fill: C.sec, fontSize: 10 }} />
              <Tooltip content={<TT />} />
              <Bar dataKey="v" fill={C.gold} name="Auftr√§ge" radius={[4,4,0,0]} />
            </BarChart>
          </ResponsiveContainer>
          <div style={{ fontSize: 11, color: C.sec, marginTop: 4 }}>
            {d.weekday.map(w => `${w.d}: √ò${w.avg}`).join(' ¬∑ ')}
          </div>
        </Sec>

        <Sec title="‚ö° kWp-Verteilung">
          <ResponsiveContainer width="100%" height={200}>
            <PieChart>
              <Pie data={d.kwpDist} cx="50%" cy="50%" outerRadius={70} dataKey="v" label={({ name, v }) => `${name}: ${v}`}>
                {d.kwpDist.map((_, i) => <Cell key={i} fill={CL[i]} />)}
              </Pie>
              <Tooltip />
            </PieChart>
          </ResponsiveContainer>
        </Sec>
      </div>

      {/* Berater Ranking */}
      <Sec title="üèÜ Berater-Ranking" sub="Sortiert nach aktiven Auftr√§gen">
        <RankTable data={d.berater.slice(0, 25)} columns={[
          { label: '#', render: (_, i) => i + 1, align: 'center', bold: true },
          { label: 'Berater', key: 'n', bold: true },
          { label: 'Aktiv', key: 's', align: 'center', mono: true, bold: true, color: r => r.s > 5 ? C.green : C.text },
          { label: 'Storno', key: 'st', align: 'center', mono: true, color: () => C.red },
          { label: 'Netto', render: r => eur(r.net), align: 'right', mono: true },
          { label: 'Speicher', key: 'speicher', align: 'center', mono: true, color: () => C.blue },
          { label: 'Storno%', render: r => `${pct(r.st, r.s + r.st)}%`, align: 'center', mono: true },
        ]} />
      </Sec>

      {/* Quellen Ranking */}
      <Sec title="üì° Lead-Quellen Performance" sub="Aktive Auftr√§ge nach Herkunft">
        <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: 18 }} className="grid-1">
          <ResponsiveContainer width="100%" height={250}>
            <PieChart>
              <Pie data={d.quellen.filter(q => q.s > 0)} cx="50%" cy="50%" outerRadius={80} dataKey="s" label={({ n, s }) => `${n}: ${s}`}>
                {d.quellen.map((_, i) => <Cell key={i} fill={CL[i % CL.length]} />)}
              </Pie>
              <Tooltip />
            </PieChart>
          </ResponsiveContainer>
          <RankTable data={d.quellen} columns={[
            { label: 'Quelle', key: 'n', bold: true },
            { label: 'Gesamt', key: 'b', align: 'center', mono: true },
            { label: 'Aktiv', key: 's', align: 'center', mono: true, bold: true, color: () => C.green },
            { label: 'Storno', key: 'st', align: 'center', mono: true, color: () => C.red },
            { label: 'Netto ‚Ç¨', render: r => eur(r.net), align: 'right', mono: true },
          ]} />
        </div>
      </Sec>
    </div>
  );
};

// ‚ïê‚ïê‚ïê TAB: LEADS ‚ïê‚ïê‚ïê
const FunnelBar = ({ label, value, total, color, icon }) => {
  const pctVal = total > 0 ? (value/total*100) : 0;
  return (
    <div style={{ display:'flex', alignItems:'center', gap:10, padding:'8px 0' }}>
      <span style={{ fontSize:16, width:24, textAlign:'center' }}>{icon}</span>
      <div style={{ flex:1, minWidth:0 }}>
        <div style={{ display:'flex', justifyContent:'space-between', marginBottom:4 }}>
          <span style={{ fontSize:12, color:C.sec, fontWeight:500 }}>{label}</span>
          <span style={{ fontSize:13, fontWeight:700, color, fontFamily:'JetBrains Mono, monospace' }}>{fmt(value)} <span style={{ fontSize:10, color:C.dim, fontWeight:400 }}>({pctVal.toFixed(1)}%)</span></span>
        </div>
        <div style={{ height:6, borderRadius:3, background:`${C.dim}30` }}>
          <div style={{ width:`${Math.max(pctVal,0.5)}%`, height:'100%', borderRadius:3, background:color, transition:'width .6s ease', boxShadow:`0 0 8px ${color}40` }} />
        </div>
      </div>
    </div>
  );
};

const MiniStat = ({ label, value, sub, color }) => (
  <div style={{ background:C.card2, borderRadius:10, padding:'12px 14px', border:`1px solid ${C.border}`, flex:'1 1 120px', minWidth:100 }}>
    <div style={{ fontSize:10, color:C.sec, fontWeight:600, textTransform:'uppercase', letterSpacing:.5, marginBottom:4 }}>{label}</div>
    <div style={{ fontSize:20, fontWeight:800, color:color||C.text, fontFamily:'JetBrains Mono, monospace' }}>{value}</div>
    {sub && <div style={{ fontSize:10, color:C.dim, marginTop:2 }}>{sub}</div>}
  </div>
);

const TabLeads = ({ data, hasWarning }) => {
  if (!data) return null;
  const d = data;
  const f = d.funnel;
  const convRate = d.total > 0 ? (f.terminiert/d.total*100).toFixed(1) : '0';
  const auftrRate = d.total > 0 ? (f.auftrag/d.total*100).toFixed(1) : '0';
  const neRate = d.total > 0 ? (f.ne/d.total*100).toFixed(1) : '0';

  return (
    <div style={{ display: 'flex', flexDirection: 'column', gap: 18 }}>
      {hasWarning && <DataWarning msg="Die Leveto-Leads sind m√∂glicherweise nicht vollst√§ndig synchronisiert. Angezeigte Daten basieren auf dem letzten Sync-Stand." />}

      {/* ‚îÄ‚îÄ KPI Row ‚îÄ‚îÄ */}
      <div style={{ display:'flex', gap:10, flexWrap:'wrap' }}>
        <MiniStat label="Leads gesamt" value={fmt(d.total)} color={C.blue} />
        <MiniStat label="Terminiert" value={fmt(f.terminiert)} sub={`${convRate}% Quote`} color={C.green} />
        <MiniStat label="Auftrag" value={fmt(f.auftrag)} sub={`${auftrRate}% der Leads`} color={C.gold} />
        <MiniStat label="Storno" value={fmt(f.storno)} color={C.red} />
        <MiniStat label="Nicht erreicht" value={fmt(f.ne)} sub={`${neRate}%`} color={C.orange} />
        <MiniStat label="√ò Bearbeitung" value={d.processing.median > 0 ? (d.processing.median < 24 ? `${d.processing.median.toFixed(0)}h` : `${(d.processing.median/24).toFixed(1)}d`) : '‚Äì'} sub={d.processing.count > 0 ? `${fmt(d.processing.count)} gemessen` : ''} color={C.cyan} />
      </div>

      {/* ‚îÄ‚îÄ Funnel + Status ‚îÄ‚îÄ */}
      <div style={{ display:'grid', gridTemplateColumns:'1fr 1fr', gap:18 }} className="grid-1">
        <Sec title="üîª Lead-Funnel" sub="Vom Eingang zum Abschluss">
          <FunnelBar label="Gesamt eingegangen" value={d.total} total={d.total} color={C.blue} icon="üì•" />
          <FunnelBar label="Terminiert" value={f.terminiert} total={d.total} color={C.green} icon="üìÖ" />
          <FunnelBar label="Auftrag / Sale" value={f.auftrag} total={d.total} color={C.gold} icon="üéâ" />
          <FunnelBar label="Kein Interesse" value={f.keinInt} total={d.total} color={C.dim} icon="üö´" />
          <FunnelBar label="Nicht erreicht" value={f.ne} total={d.total} color={C.orange} icon="üìµ" />
          <FunnelBar label="WVL / Wiedervorlage" value={f.wvl} total={d.total} color={C.blue} icon="üîÑ" />
          <FunnelBar label="Nicht im PLZ-Gebiet" value={f.noPLZ} total={d.total} color={C.purple} icon="üìç" />
          <FunnelBar label="Storniert" value={f.storno} total={d.total} color={C.red} icon="‚ùå" />
          <FunnelBar label="REKLAMATION" value={f.rekl} total={d.total} color="#F85149" icon="‚ö†Ô∏è" />
          {f.hasEFS > 0 && <FunnelBar label="EFS verkn√ºpft" value={f.hasEFS} total={d.total} color={C.cyan} icon="üîó" />}
        </Sec>

        <Sec title="üìä Status-Verteilung">
          <ResponsiveContainer width="100%" height={280}>
            <PieChart>
              <Pie data={d.status.slice(0, 10)} cx="50%" cy="50%" outerRadius={85} innerRadius={40} dataKey="v" paddingAngle={2}
                label={({ name, v }) => v > d.total*0.03 ? `${name}: ${v}` : ''} labelLine={false} style={{ fontSize: 10 }}>
                {d.status.slice(0, 10).map((s, i) => <Cell key={i} fill={s.fill || CL[i % CL.length]} />)}
              </Pie>
              <Tooltip contentStyle={{ background:C.card, border:`1px solid ${C.border}`, borderRadius:8, color:C.text, fontSize:12 }} />
            </PieChart>
          </ResponsiveContainer>
          <div style={{ display:'flex', flexWrap:'wrap', gap:6, marginTop:8, justifyContent:'center' }}>
            {d.status.slice(0,10).map((s,i) => (
              <span key={i} style={{ fontSize:10, color:C.sec, display:'flex', alignItems:'center', gap:4 }}>
                <span style={{ width:8, height:8, borderRadius:2, background:s.fill||CL[i%CL.length], flexShrink:0 }} />
                {s.name} ({fmt(s.v)})
              </span>
            ))}
          </div>
        </Sec>
      </div>

      {/* ‚îÄ‚îÄ Timeline ‚îÄ‚îÄ */}
      {d.weekly.length > 2 && (
        <Sec title="üìà Lead-Verlauf (Wochen)" sub="Eingegangene Leads vs. Terminierte">
          <ResponsiveContainer width="100%" height={220}>
            <ComposedChart data={d.weekly} margin={{ top:5, right:10, left:0, bottom:5 }}>
              <CartesianGrid strokeDasharray="3 3" stroke={C.border} />
              <XAxis dataKey="d" stroke={C.dim} tick={{ fontSize:10, fill:C.sec }} />
              <YAxis stroke={C.dim} tick={{ fontSize:10, fill:C.sec }} />
              <Tooltip contentStyle={{ background:C.card, border:`1px solid ${C.border}`, borderRadius:8, color:C.text, fontSize:12 }} />
              <Area type="monotone" dataKey="total" name="Leads" fill={`${C.blue}20`} stroke={C.blue} strokeWidth={2} />
              <Line type="monotone" dataKey="term" name="Terminiert" stroke={C.green} strokeWidth={2} dot={{ r:3, fill:C.green }} />
            </ComposedChart>
          </ResponsiveContainer>
        </Sec>
      )}

      {/* ‚îÄ‚îÄ Quellen + Berater ‚îÄ‚îÄ */}
      <div style={{ display:'grid', gridTemplateColumns:'1fr 1fr', gap:18 }} className="grid-1">
        <Sec title="üì° Leads nach Quelle" sub="Mit Terminierungs- & Auftragsquote">
          <RankTable data={d.quellen.filter(q=>q.total>1)} columns={[
            { label: 'Quelle', key: 'n', bold: true },
            { label: 'Leads', key: 'total', align: 'center', mono: true, bold: true },
            { label: 'Term.', key: 'term', align: 'center', mono: true, color: () => C.green },
            { label: 'Auftr.', key: 'auftrag', align: 'center', mono: true, color: () => C.gold },
            { label: 'NE', key: 'ne', align: 'center', mono: true, color: () => C.orange },
            { label: 'T-Rate', render: r => `${r.total > 0 ? (r.term/r.total*100).toFixed(0) : 0}%`, align: 'center', mono: true, color: r => r.total > 3 && r.term/r.total > 0.15 ? C.green : C.sec },
          ]} />
        </Sec>

        <Sec title="üèÜ Berater-Ranking" sub="Nach Terminierungsleistung">
          <RankTable data={d.beraterLeads.filter(b => b.total > 5).slice(0, 20)} columns={[
            { label: '#', render: (_, i) => i + 1, align: 'center' },
            { label: 'Berater', key: 'n', bold: true },
            { label: 'Leads', key: 'total', align: 'center', mono: true },
            { label: 'Term.', key: 'term', align: 'center', mono: true, bold: true, color: () => C.green },
            { label: 'Auftr.', key: 'auftrag', align: 'center', mono: true, color: () => C.gold },
            { label: 'NE', key: 'ne', align: 'center', mono: true, color: () => C.orange },
            { label: 'Quote', render: r => `${r.total > 0 ? (r.term/r.total*100).toFixed(0) : 0}%`, align: 'center', mono: true, color: r => r.total > 5 && r.term/r.total > 0.2 ? C.green : C.sec },
          ]} />
        </Sec>
      </div>

      {/* ‚îÄ‚îÄ Geo-Analyse ‚îÄ‚îÄ */}
      <div style={{ display:'grid', gridTemplateColumns:'1fr 1fr', gap:18 }} className="grid-1">
        <Sec title="üó∫Ô∏è Top St√§dte" sub="Nach Lead-Aufkommen">
          <div style={{ maxHeight:380, overflowY:'auto' }}>
            <RankTable data={d.topOrte.slice(0,15)} columns={[
              { label: '#', render: (_, i) => i + 1, align: 'center' },
              { label: 'Stadt', key: 'n', bold: true },
              { label: 'PLZ', key: 'plz', align: 'center', mono: true, color: () => C.dim },
              { label: 'Leads', key: 'total', align: 'center', mono: true, bold: true },
              { label: 'Term.', key: 'term', align: 'center', mono: true, color: () => C.green },
              { label: 'Rate', render: r => `${r.total > 0 ? (r.term/r.total*100).toFixed(0) : 0}%`, align: 'center', mono: true },
            ]} />
          </div>
        </Sec>

        <Sec title="üìÆ PLZ-Regionen" sub="Erste 2 Stellen der PLZ">
          <ResponsiveContainer width="100%" height={Math.min(d.plzRegionen.length * 28 + 30, 380)}>
            <BarChart data={d.plzRegionen} layout="vertical" margin={{ top:5, right:10, left:40, bottom:5 }}>
              <CartesianGrid strokeDasharray="3 3" stroke={C.border} horizontal={false} />
              <XAxis type="number" stroke={C.dim} tick={{ fontSize:10, fill:C.sec }} />
              <YAxis type="category" dataKey="n" stroke={C.dim} tick={{ fontSize:10, fill:C.sec }} width={50} />
              <Tooltip contentStyle={{ background:C.card, border:`1px solid ${C.border}`, borderRadius:8, color:C.text, fontSize:12 }} />
              <Bar dataKey="total" name="Leads" fill={C.blue} radius={[0,4,4,0]} barSize={16} />
              <Bar dataKey="term" name="Terminiert" fill={C.green} radius={[0,4,4,0]} barSize={16} />
            </BarChart>
          </ResponsiveContainer>
        </Sec>
      </div>

      {/* ‚îÄ‚îÄ Full Status Table ‚îÄ‚îÄ */}
      <Sec title="üìã Alle Status" sub={`${d.status.length} verschiedene Status`}>
        <div style={{ maxHeight:350, overflowY:'auto' }}>
          <RankTable data={d.status} columns={[
            { label: '#', render: (_, i) => i + 1, align: 'center' },
            { label: 'Status', key: 'name', bold: true, render: r => <span style={{ display:'flex', alignItems:'center', gap:6 }}><span style={{ width:8, height:8, borderRadius:2, background:r.fill, flexShrink:0 }} />{r.name}</span> },
            { label: 'Anzahl', key: 'v', align: 'center', mono: true, bold: true },
            { label: 'Anteil', render: r => `${(r.v/d.total*100).toFixed(1)}%`, align: 'center', mono: true, color: () => C.sec },
          ]} />
        </div>
      </Sec>
    </div>
  );
};

// ‚ïê‚ïê‚ïê TAB: TERMINE ‚ïê‚ïê‚ïê
const TabTermine = ({ data }) => {
  if (!data) return null;
  const d = data;

  return (
    <div style={{ display: 'flex', flexDirection: 'column', gap: 18 }}>
      <div style={{ display: 'flex', gap: 12, flexWrap: 'wrap' }} className="grid-cards">
        <KPI label="Termine gelegt" value={fmt(d.total)} sub={d.nGelegtHeute > 0 ? `+${d.nGelegtHeute} heute` : ''} color={C.gold} />
        <KPI label="Stattgefunden" value={fmt(d.nStattgefunden)} sub={`${d.convRate.toFixed(1)}% Stattfinde-Quote`} color={C.green} />
        <KPI label="Ausgefallen" value={fmt(d.nAusgefallen)} sub={`${pct(d.nAusgefallen, d.nStattgefunden + d.nAusgefallen)}% Ausfallquote`} color={C.red} />
        <KPI label="Geplant" value={fmt(d.nZukunft)} sub="Zuk√ºnftige Termine" color={C.blue} />
        {d.nHeute > 0 && <KPI label="Heute" value={fmt(d.nHeute)} sub="Termine heute" color={C.amber} />}
      </div>

      <Sec title="üìÖ T√§gliche Termine" sub="Nach Termin-Datum">
        <ResponsiveContainer width="100%" height={260}>
          <BarChart data={d.daily}>
            <CartesianGrid strokeDasharray="3 3" stroke={C.border} />
            <XAxis dataKey="d" tick={{ fill: C.sec, fontSize: 10 }} interval={Math.max(0, Math.floor(d.daily.length / 12))} />
            <YAxis tick={{ fill: C.sec, fontSize: 10 }} />
            <Tooltip content={<TT />} />
            <Bar dataKey="gesamt" fill={C.gold} name="Gesamt" radius={[4,4,0,0]} />
            <Bar dataKey="stattgef" fill={C.green} name="Stattgefunden" radius={[4,4,0,0]} />
            <Bar dataKey="ausgef" fill={C.red} name="Ausgefallen" radius={[4,4,0,0]} />
          </BarChart>
        </ResponsiveContainer>
      </Sec>

      <Sec title="üì° Quellen" sub="Woher kommen die Termine?">
        <RankTable data={d.quellen.slice(0, 15)} columns={[
          { label: '#', render: (_, i) => i + 1, align: 'center' },
          { label: 'Quelle', key: 'name', bold: true },
          { label: 'Gesamt', key: 'total', align: 'center', mono: true, bold: true },
          { label: 'Stattgef.', key: 'stattgefunden', align: 'center', mono: true, color: () => C.green },
          { label: 'Ausgefallen', key: 'ausgefallen', align: 'center', mono: true, color: () => C.red },
          { label: 'Quote %', render: r => { const t = r.stattgefunden + r.ausgefallen; return t > 0 ? `${pct(r.stattgefunden, t)}%` : '‚Äì'; }, align: 'center', mono: true },
        ]} />
      </Sec>

      <Sec title="üèÜ Berater Termine" sub="Sortiert nach Termin-Anzahl">
        <RankTable data={d.berater.slice(0, 20)} columns={[
          { label: '#', render: (_, i) => i + 1, align: 'center' },
          { label: 'Berater', key: 'n', bold: true },
          { label: 'Gesamt', key: 'total', align: 'center', mono: true, bold: true },
          { label: 'Stattgef.', key: 'stattgefunden', align: 'center', mono: true, color: () => C.green },
          { label: 'Ausgefallen', key: 'ausgefallen', align: 'center', mono: true, color: () => C.red },
          { label: 'Quote %', render: r => { const t = r.stattgefunden + r.ausgefallen; return t > 0 ? `${pct(r.stattgefunden, t)}%` : '‚Äì'; }, align: 'center', mono: true },
        ]} />
      </Sec>
    </div>
  );
};

// ‚ïê‚ïê‚ïê TAB: MONTAGE / EFS ‚ïê‚ïê‚ïê
const TabEFS = ({ data }) => {
  if (!data) return null;
  const d = data;

  return (
    <div style={{ display: 'flex', flexDirection: 'column', gap: 18 }}>
      <div style={{ display: 'flex', gap: 12, flexWrap: 'wrap' }} className="grid-cards">
        <KPI label="Projekte gesamt" value={fmt(d.total)} color={C.gold} />
        <KPI label="Aktiv (Pipeline)" value={fmt(d.activeCount)} sub={`√ò ${eur(d.avgPrice)}`} color={C.green} />
        <KPI label="Gesamtvolumen" value={eur(d.totalRevenue)} sub={`${d.totalKwp.toFixed(0)} kWp gesamt`} color={C.blue} />
        <KPI label="√ò Anlage" value={`${d.avgKwp.toFixed(1)} kWp`} sub={`${d.withBat} mit Batterie (${pct(d.withBat, d.activeCount)}%)`} color={C.purple} />
      </div>

      <Sec title="üîÑ EFS Pipeline" sub="Alle Projekte nach Status">
        <ResponsiveContainer width="100%" height={300}>
          <BarChart data={d.pipeline} layout="vertical">
            <CartesianGrid strokeDasharray="3 3" stroke={C.border} />
            <XAxis type="number" tick={{ fill: C.sec, fontSize: 10 }} />
            <YAxis type="category" dataKey="name" tick={{ fill: C.sec, fontSize: 10 }} width={140} />
            <Tooltip content={<TT />} />
            <Bar dataKey="v" name="Projekte" radius={[0,4,4,0]}>
              {d.pipeline.map((p, i) => <Cell key={i} fill={p.fill || CL[i % CL.length]} />)}
            </Bar>
          </BarChart>
        </ResponsiveContainer>
      </Sec>

      <Sec title="üë∑ Projekte nach Zust√§ndigem" sub="Top-Vertriebler/Projektleiter">
        <RankTable data={d.zustaendige.slice(0, 20)} columns={[
          { label: '#', render: (_, i) => i + 1, align: 'center' },
          { label: 'Zust√§ndiger', key: 'n', bold: true },
          { label: 'Gesamt', key: 'total', align: 'center', mono: true, bold: true },
          { label: 'Aktiv', key: 'active', align: 'center', mono: true, color: () => C.green },
          { label: 'Fertig', key: 'completed', align: 'center', mono: true, color: () => C.blue },
          { label: 'Widerrufen', key: 'revoked', align: 'center', mono: true, color: () => C.red },
          { label: 'Umsatz', render: r => eur(r.revenue), align: 'right', mono: true },
        ]} />
      </Sec>
    </div>
  );
};

// ‚ïê‚ïê‚ïê MAIN APP ‚ïê‚ïê‚ïê
const App = () => {
  const availableMonths = useMemo(() => getAvailableMonths(), []);
  const [selectedMonth, setSelectedMonth] = useState(() => {
    const now = new Date();
    return { year: now.getFullYear(), month: now.getMonth() + 1 };
  });
  const [tab, setTab] = useState('sales');
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [lastUpdate, setLastUpdate] = useState(null);

  // Raw data
  const [auftraege, setAuftraege] = useState([]);
  const [leads, setLeads] = useState([]);
  const [termine, setTermine] = useState([]);
  const [efsProjekte, setEfsProjekte] = useState([]);
  const [mitarbeiterList, setMitarbeiterList] = useState([]);
  const [vertriebler, setVertriebler] = useState([]);

  // Name maps
  const mitarbeiterMap = useMemo(() => {
    const map = {};
    mitarbeiterList.forEach(m => {
      map[m.id] = `${m.vorname} ${m.nachname}`.trim();
    });
    return map;
  }, [mitarbeiterList]);

  const vertrMap = useMemo(() => {
    const map = {};
    vertriebler.forEach(v => { map[v.id] = v.name; });
    return map;
  }, [vertriebler]);

  // Data fetching
  const fetchData = useCallback(async () => {
    setLoading(true);
    setError(null);
    try {
      const isAll = selectedMonth.year === 0;
      const start = isAll ? '2025-10-01' : `${selectedMonth.year}-${String(selectedMonth.month).padStart(2,'0')}-01`;
      const nextMonth = isAll ? `${new Date().getFullYear() + 1}-01-01` : (selectedMonth.month === 12 ? `${selectedMonth.year+1}-01-01` : `${selectedMonth.year}-${String(selectedMonth.month+1).padStart(2,'0')}-01`);

      const [auftraegeData, leadsData, termineData, efsData, maData, vertrData] = await Promise.all([
        sbFetchAll('auftraege', `auftrags_datum=gte.${start}&auftrags_datum=lt.${nextMonth}&order=auftrags_datum.asc`),
        sbFetchAll('leveto_leads', `erster_status_datum=gte.${start}&erster_status_datum=lt.${nextMonth}&order=erster_status_datum.asc`),
        sbFetchAll('leveto_termine', `start_date=gte.${start}&start_date=lt.${nextMonth}&appointment_type=in.("Termin vor Ort PV","Termin vor Ort ( SCOUT )","Folgetermin vor Ort")&order=start_date.asc`),
        sbFetchAll('efs_projekte', 'order=erstellt_am.desc'),
        sbFetch('mitarbeiter', 'select=id,vorname,nachname,kuerzel,typ&limit=500'),
        sbFetch('vertriebler', 'select=id,name&limit=100'),
      ]);

      setAuftraege(auftraegeData);
      setLeads(leadsData);
      setTermine(termineData);
      setEfsProjekte(efsData);
      setMitarbeiterList(maData);
      setVertriebler(vertrData);
      setLastUpdate(new Date());
    } catch (err) {
      console.error('Fetch error:', err);
      setError(err.message);
    }
    setLoading(false);
  }, [selectedMonth]);

  useEffect(() => { fetchData(); }, [fetchData]);

  // Processed data
  const salesData = useMemo(() => auftraege.length > 0 ? processAuftraege(auftraege, mitarbeiterMap) : null, [auftraege, mitarbeiterMap]);
  const leadsData = useMemo(() => leads.length > 0 ? processLeads(leads) : null, [leads]);
  const termineData = useMemo(() => termine.length > 0 ? processTermine(termine) : null, [termine]);
  const efsData = useMemo(() => efsProjekte.length > 0 ? processEFS(efsProjekte) : null, [efsProjekte]);

  const monthLabel = selectedMonth.year === 0 ? 'Gesamt (ab Okt 2025)' : `${monthNames[selectedMonth.month - 1]} ${selectedMonth.year}`;

  return (
    <div style={{ maxWidth: 1400, margin: '0 auto', padding: '60px 20px 40px' }}>
      {/* Header */}
      <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginBottom: 24, flexWrap: 'wrap', gap: 12 }}>
        <div>
          <div style={{ display: 'flex', alignItems: 'center', gap: 12 }}>
            <span style={{ fontSize: 28, fontWeight: 800, color: C.text }}>bee-doo</span>
            <span style={{ fontSize: 28, fontWeight: 800, color: C.gold }}>Reporting</span>
            <span style={{ background: '#22c55e20', color: '#22c55e', padding: '3px 10px', borderRadius: 20, fontSize: 10, fontWeight: 700 }}>‚óè LIVE</span>
          </div>
          <div style={{ fontSize: 12, color: C.sec, marginTop: 2 }}>
            Daten direkt aus Supabase ¬∑ Letztes Update: {lastUpdate ? lastUpdate.toLocaleString('de-DE') : '‚Äì'}
          </div>
        </div>

        <div style={{ display: 'flex', alignItems: 'center', gap: 10 }}>
          <select
            value={`${selectedMonth.year}-${selectedMonth.month}`}
            onChange={e => {
              const [y, m] = e.target.value.split('-').map(Number);
              setSelectedMonth({ year: y, month: m });
            }}
            style={{
              background: C.card, border: `1px solid ${C.border}`, color: C.text,
              padding: '8px 14px', borderRadius: 10, fontSize: 14, fontWeight: 600, cursor: 'pointer',
            }}
          >
            {availableMonths.map(m => (
              <option key={`${m.year}-${m.month}`} value={`${m.year}-${m.month}`}>{m.label}</option>
            ))}
          </select>
          <button
            onClick={fetchData}
            disabled={loading}
            style={{
              background: loading ? C.dim : C.gold, color: '#000', border: 'none',
              padding: '8px 16px', borderRadius: 10, fontSize: 13, fontWeight: 700,
              cursor: loading ? 'wait' : 'pointer',
            }}
          >
            {loading ? '‚è≥' : 'üîÑ'} Refresh
          </button>
        </div>
      </div>

      {error && (
        <div style={{ background: `${C.red}15`, border: `1px solid ${C.red}40`, borderRadius: 12, padding: 16, marginBottom: 18, color: C.red, fontSize: 13 }}>
          ‚ùå Fehler beim Laden: {error}
        </div>
      )}

      {loading ? <LoadingSpinner /> : (
        <>
          {/* Overview KPIs */}
          <div style={{ display: 'flex', gap: 12, flexWrap: 'wrap', marginBottom: 24 }} className="grid-cards">
            <KPI label="Auftr√§ge aktiv" value={fmt(salesData?.aktiv || 0)} sub={`${monthLabel}`} color={C.gold} />
            <KPI label="Umsatz Netto" value={eur(salesData?.nettoAktiv || 0)} color={C.green} />
            <KPI label="Leads" value={fmt(leadsData?.total || leads.length)} sub={leadsData?.funnel ? `${fmt(leadsData.funnel.terminiert)} terminiert` : (leads.length < 100 ? "‚ö†Ô∏è Sync unvollst." : "")} color={C.blue} />
            <KPI label="Termine" value={fmt(termineData?.total || 0)} color={C.purple} />
            <KPI label="EFS Pipeline" value={fmt(efsData?.activeCount || 0)} sub={eur(efsData?.totalRevenue || 0)} color={C.cyan} />
          </div>

          {/* Tabs */}
          <div style={{ display: 'flex', gap: 8, marginBottom: 20, overflowX: 'auto', paddingBottom: 4 }}>
            <TabBtn active={tab === 'sales'} onClick={() => setTab('sales')} count={salesData?.aktiv}>üìä Sales</TabBtn>
            <TabBtn active={tab === 'leads'} onClick={() => setTab('leads')} count={leadsData?.total || leads.length}>üì• Leads</TabBtn>
            <TabBtn active={tab === 'termine'} onClick={() => setTab('termine')} count={termineData?.total}>üìÖ Termine</TabBtn>
            <TabBtn active={tab === 'efs'} onClick={() => setTab('efs')} count={efsData?.total}>üîß EFS/Montage</TabBtn>
          </div>

          {/* Tab Content */}
          {tab === 'sales' && <TabSales data={salesData} />}
          {tab === 'leads' && <TabLeads data={leadsData || { total: 0, status: [], quellen: [], beraterLeads: [], weekly: [], topOrte: [], plzRegionen: [], anredeMap: {}, indicatorMap: {}, funnel: { terminiert:0, auftrag:0, storno:0, ne:0, keinInt:0, rekl:0, neu:0, wvl:0, noPLZ:0, optIn:0, hasEFS:0 }, processing: { median:0, avg:0, count:0 } }} hasWarning={leads.length < 100} />}
          {tab === 'termine' && <TabTermine data={termineData} />}
          {tab === 'efs' && <TabEFS data={efsData} />}

          {/* Footer */}
          <div style={{ textAlign: 'center', color: C.dim, fontSize: 11, marginTop: 40, padding: 20 }}>
            bee-doo GmbH ¬∑ Reporting Dashboard ¬∑ Live-Daten aus Supabase<br />
            {auftraege.length} Auftr√§ge ¬∑ {leads.length} Leads ¬∑ {termine.length} Termine ¬∑ {efsProjekte.length} EFS-Projekte geladen
          </div>
        </>
      )}
    </div>
  );
};

ReactDOM.createRoot(document.getElementById('root')).render(<App />);
</script>
</body>
</html>
